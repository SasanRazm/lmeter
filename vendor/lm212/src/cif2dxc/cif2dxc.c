/*
 *   LMeter: Multilayer superconductive inductance extractor
 *   
 *   Copyright (C) 1992-1999 Paul Bunyk
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 *    Main file of the 'cif2dxc' program.
 */

#include"cifgeom.h"
#include<assert.h>

#include<string.h>

FILE           *dxc;
FILE           *term;

/*
 *    Table to store terminals' config info.
 *      NB: Terminals are counted starting from 1 (for historical reasons)
 */
#define	NAMLEN	32
#define	MAXNTRM	(8*sizeof(unsigned))
struct
{
    char            name[NAMLEN];
    char            uplay[NAMLEN];
    char            dnlay[NAMLEN];
    char            ttype;
}
termTab[MAXNTRM];

int             ntrm = 0;
int             itrm = 0;

/*
 *    Function:       dxcout
 *      Definition:     Write one pline to the output DXC file.
 */

char           *termout = "lmeter.term";
char           *termnames = "term.name";
int             termUserExt = 5;
char           *termUserExtFormat = " 99 %s %s %s %s";

dxcout (geomprim * prim)
{
    point           pnt1;

    switch (prim->type)
    {
    case PLINE:
	fprintf (dxc, "$POLYLINE\n");
	fprintf (dxc, "%s\n", prim->par.pline.layname);
	fprintf (dxc, "%d\n", itrm);

	foreach
	    (pnt, prim->par.pline.pntlist,
	     {
	     transpnt (&pnt1, pnt->car);
	     fprintf (dxc, "\t%10.2f\t%10.2f\n",
		      (double) pnt1.x,
		      (double) pnt1.y);
	     }
	);
	break;
    case UEXT:
	if (prim->par.uext.no == termUserExt)
	{
	    char            tname[NAMLEN];
	    char            tup[NAMLEN];
	    char            tdown[NAMLEN];
	    char            ttype[NAMLEN];
	    int             numfields = sscanf (prim->par.uext.text,
						termUserExtFormat,
						tname, tdown, tup, ttype);

	    if (numfields)
	    {
		for (itrm = 1; itrm <= ntrm; itrm++)
		    if (strcmp (termTab[itrm].name, tname) == 0)
			break;
		if (itrm == ntrm + 1)
		{
		    ntrm++;
		    if (ntrm == MAXNTRM)
			error ("Too many terminals");
		    else
		    {
			strcpy (termTab[itrm].name, tname);

			if (numfields > 1)
			    strcpy (termTab[itrm].dnlay, tdown);
			else
			    strcpy (termTab[itrm].dnlay, "*");

			if (numfields > 2)
			    strcpy (termTab[itrm].uplay, tup);
			else
			    strcpy (termTab[itrm].uplay, "*");

			if (numfields > 3)
			    termTab[itrm].ttype = ttype[0];
			else
			    termTab[itrm].ttype = 'I';

		    }
		}
		else
		    warning ("Several terminals have the same name");
	    }
	    else
		fprintf (stderr,
			 "User Extension '%d %s' is not a terminal\n",
			 termUserExt, prim->par.uext.text);
	}
	break;
    }
    return 0;
}				/*      dxcout  */

main (int argc, char **argv)
{
    extern FILE    *yyin;	/*      from cif.l      */
    int             t;

    if (argc > 3)
    {
	fprintf (stderr, "Call: %s [cifFilename [dxcFilename]]\n", argv[0]);
	return 1;
    }

    /*
     *    Read input file to internal data structures
     */
    if (argc > 1)
	fileopen (yyin, argv[1], "r");
    else
	yyin = stdin;
    yyparse ();
    fclose (yyin);

    /*
     *    Write output file
     */
    if (argc > 2)
	fileopen (dxc, argv[2], "w");
    else
	dxc = stdout;
    fprintf (dxc, "$ENTITIES\n");
    walkroot (dxcout);
    fprintf (dxc, "$EOF\n");
    fclose (dxc);

    /*
     *    Dump termTab to files
     */
    fileopen (term, termout, "w");
    fprintf (term, "# Terminal descriptions generated by the `cif2dxc' program\n\n");
    fprintf (term, "nterm\t%d\n", ntrm);
    fprintf (term, "termname\t");
    for (t = 1; t <= ntrm; t++)
	fprintf (term, "%s\t", termTab[t].name);
    fprintf (term, "\n");
    fprintf (term, "termtype\t");
    for (t = 1; t <= ntrm; t++)
	fprintf (term, "%c\t", termTab[t].ttype);
    fprintf (term, "\n");
    fprintf (term, "termup  \t");
    for (t = 1; t <= ntrm; t++)
	fprintf (term, "%s\t", termTab[t].uplay);
    fprintf (term, "\n");
    fprintf (term, "termdown\t");
    for (t = 1; t <= ntrm; t++)
	fprintf (term, "%s\t", termTab[t].dnlay);
    fprintf (term, "\n");
    fclose (term);
    fileopen (term, termnames, "w");
    for (t = 1; t <= ntrm; t++)
	fprintf (term, "%s\t%d\n", termTab[t].name, t);
    fclose (term);

    return 0;
}

int
userprocess ()
{
    /*      fprintf(stderr,"User ext:%d %s\n",userextno,userexttext);       
     */
    switch (userextno)
    {
    case 9:
	fprintf (stderr, "Processing cell %s ...\n", userexttext);
	break;
    }

    return 0;
}
